#!/usr/bin/env node

/**
 * Initialize Version History from Git
 * 
 * This script analyzes the master branch git history to:
 * 1. Identify significant milestones based on commits
 * 2. Initialize the version system
 * 3. Create deployment history
 * 4. Generate milestones.json and deployments.json
 */

const { execSync } = require('child_process')
const fs = require('fs')
const path = require('path')

const versionsDirectory = path.join(process.cwd(), 'data/versions')
const milestonesFile = path.join(versionsDirectory, 'milestones.json')
const deploymentsFile = path.join(versionsDirectory, 'deployments.json')
const versionFile = path.join(versionsDirectory, 'current-version.json')

function executeGitCommand(command) {
  try {
    return execSync(command, { encoding: 'utf8', cwd: process.cwd(), stdio: 'pipe' }).trim()
  } catch (error) {
    return null
  }
}

function checkGitAvailable() {
  try {
    execSync('git --version', { stdio: 'ignore' })
    return true
  } catch {
    return false
  }
}

function checkGitRepository() {
  try {
    execSync('git rev-parse --git-dir', { stdio: 'ignore' })
    return true
  } catch {
    return false
  }
}

function getFirstCommit() {
  try {
    const hash = executeGitCommand('git rev-list --max-parents=0 HEAD')
    if (hash) {
      const date = executeGitCommand(`git log -1 --format=%ai ${hash}`)
      return { hash, date: date ? date.split(' ')[0] : null }
    }
  } catch {
    return null
  }
  return null
}

function getCommitsByCategory() {
  const logFormat = '%H|%h|%s|%an|%ai|%P'
  const logCommand = `git log --all --pretty=format:"${logFormat}" --reverse`
  const logOutput = executeGitCommand(logCommand)
  
  if (!logOutput) return []
  
  const commits = []
  const lines = logOutput.split('\n').filter(line => line.trim())
  
  for (const line of lines) {
    if (line.includes('|') && line.split('|').length >= 6) {
      const parts = line.split('|')
      const [hash, shortHash, message, author, date, parents] = parts
      
      // Parse conventional commit tags
      const tagMatch = message.match(/^(\w+)(?:\(([^)]+)\))?:/)
      const tag = tagMatch ? tagMatch[1] : null
      const scope = tagMatch ? tagMatch[2] : null
      
      commits.push({
        hash: hash || '',
        shortHash: shortHash || hash?.substring(0, 7) || '',
        message: message || '',
        author: author || '',
        date: date ? date.split(' ')[0] : '',
        tag: tag || null,
        scope: scope || null,
        parents: parents ? parents.split(' ').filter(p => p) : []
      })
    }
  }
  
  return commits
}

function identifyMilestones(commits) {
  const milestones = []
  let milestoneVersion = { major: 1, minor: 0, patch: 0 }
  
  // Find the first commit (initial launch)
  const firstCommit = commits[0]
  let lastMilestoneDate = null
  
  if (firstCommit) {
    // Initial milestone - look for "Initial" or first significant commit
    const initialCommit = commits.find(c => 
      c.message.toLowerCase().includes('initial') ||
      c.message.toLowerCase().includes('first')
    ) || firstCommit
    
    milestones.push({
      version: '1.0.0',
      date: initialCommit.date,
      title: 'Initial Launch',
      description: initialCommit.message || 'Website launched with initial features and structure',
      features: extractFeaturesFromCommit(initialCommit),
      autoGenerated: true,
      stats: {
        commits: 1
      }
    })
    lastMilestoneDate = initialCommit.date
    milestoneVersion = { major: 1, minor: 0, patch: 0 }
  }
  
  // Group commits by date and identify significant milestones
  // Look for major feature additions, not just any feat commit
  const significantScopes = ['blog', 'project', 'admin', 'deployment', 'analytics', 'version', 'monitoring']
  const significantCommits = commits.filter(commit => {
    const msg = commit.message.toLowerCase()
    
    // Major feature commits with significant scopes
    if (commit.tag === 'feat' && commit.scope && significantScopes.includes(commit.scope)) {
      return true
    }
    
    // Commits that add major systems
    if (msg.includes('implement') && (
      msg.includes('blog') || msg.includes('project') || msg.includes('admin') ||
      msg.includes('deployment') || msg.includes('analytics') || msg.includes('version')
    )) {
      return true
    }
    
    // Commits that add comprehensive features
    if (msg.includes('add') && (
      msg.includes('system') || msg.includes('feature') || msg.includes('integration')
    )) {
      return true
    }
    
    // Significant non-conventional commits (long messages often indicate major work)
    if (commit.tag === null && msg.length > 60 && !msg.includes('bump version')) {
      return true
    }
    
    return false
  })
  
  // Group significant commits by date to avoid too many milestones
  const commitsByDate = {}
  significantCommits.forEach(commit => {
    if (!commitsByDate[commit.date]) {
      commitsByDate[commit.date] = []
    }
    commitsByDate[commit.date].push(commit)
  })
  
  // Create milestones from grouped commits
  Object.keys(commitsByDate).sort().forEach(date => {
    if (date === lastMilestoneDate) return // Skip if same date as previous milestone
    
    const dateCommits = commitsByDate[date]
    const mainCommit = dateCommits[0] // Use first commit of the day
    
    milestoneVersion.minor += 1
    const version = `${milestoneVersion.major}.${milestoneVersion.minor}.0`
    
    // Extract features from all commits on this date
    const features = new Set()
    dateCommits.forEach(commit => {
      const commitFeatures = extractFeaturesFromCommit(commit)
      commitFeatures.forEach(f => features.add(f))
    })
    
    // Count commits since last milestone
    const commitsSinceLast = commits.filter(c => {
      const commitDate = new Date(c.date).getTime()
      const lastDate = new Date(lastMilestoneDate || firstCommit.date).getTime()
      const currentDate = new Date(date).getTime()
      return commitDate > lastDate && commitDate <= currentDate
    }).length
    
    // Create a meaningful title from the main commit
    const title = createMilestoneTitle(mainCommit, dateCommits.length)
    
    milestones.push({
      version: version,
      date: date,
      title: title,
      description: mainCommit.message || `Major update on ${date}`,
      features: Array.from(features),
      autoGenerated: true,
      stats: {
        commits: commitsSinceLast
      }
    })
    
    lastMilestoneDate = date
  })
  
  return milestones
}

function extractFeaturesFromCommit(commit) {
  const features = []
  const msg = commit.message.toLowerCase()
  
  // Extract from scope
  if (commit.scope) {
    const scopeMap = {
      'blog': 'Blog system',
      'project': 'Project showcase',
      'admin': 'Admin interface',
      'deployment': 'Deployment system',
      'analytics': 'Analytics tracking',
      'monitoring': 'Monitoring & Analytics',
      'version': 'Version history'
    }
    if (scopeMap[commit.scope]) {
      features.push(scopeMap[commit.scope])
    } else {
      features.push(`${commit.scope} feature`)
    }
  }
  
  // Extract from message keywords
  if (msg.includes('blog')) features.push('Blog system')
  if (msg.includes('project')) features.push('Project showcase')
  if (msg.includes('admin')) features.push('Admin interface')
  if (msg.includes('deployment')) features.push('Deployment system')
  if (msg.includes('analytics') || msg.includes('google analytics')) features.push('Analytics tracking')
  if (msg.includes('version') || msg.includes('versioning')) features.push('Version history')
  if (msg.includes('contact form')) features.push('Contact form')
  if (msg.includes('search')) features.push('Search functionality')
  
  return features.length > 0 ? features : ['Feature update']
}

function createMilestoneTitle(commit, commitCount) {
  const msg = commit.message
  
  // Remove conventional commit prefix if present
  let title = msg.replace(/^(feat|fix|chore|docs|style|refactor|perf|test)(\([^)]+\))?:\s*/i, '')
  
  // Capitalize first letter
  title = title.charAt(0).toUpperCase() + title.slice(1)
  
  // Limit length
  if (title.length > 60) {
    title = title.substring(0, 57) + '...'
  }
  
  // If multiple commits on same day, indicate that
  if (commitCount > 1) {
    title += ` (+${commitCount - 1} more)`
  }
  
  return title
}

function identifyDeployments(commits) {
  const deployments = []
  let deploymentVersion = { major: 1, minor: 0, patch: 0 }
  
  // Find actual deployment commits - look for commits that modify current-version.json
  // These are the real deployments, not the "bump version" commits
  const deploymentCommits = []
  
  // First, find commits that actually deployed (commits before version bumps)
  // Look for commits that have significant changes and are followed by version bumps
  commits.forEach((commit, index) => {
    const msg = commit.message.toLowerCase()
    
    // Skip "bump version" commits themselves - we want the commits that were deployed
    if (msg.includes('bump version')) {
      return
    }
    
    // Check if this commit is followed by a version bump (indicating it was deployed)
    let isDeployment = false
    for (let i = index + 1; i < Math.min(index + 5, commits.length); i++) {
      const nextCommit = commits[i]
      const nextMsg = nextCommit.message.toLowerCase()
      
      if (nextMsg.includes('bump version') || nextMsg.includes('deployment')) {
        isDeployment = true
        break
      }
    }
    
    // Also check if commit mentions deployment or production
    if (msg.includes('deploy') || msg.includes('production')) {
      isDeployment = true
    }
    
    // Group by date - one deployment per day
    if (isDeployment) {
      const existingDeployment = deploymentCommits.find(d => d.date === commit.date)
      if (!existingDeployment) {
        deploymentCommits.push(commit)
      }
    }
  })
  
  // Sort by date
  deploymentCommits.sort((a, b) => {
    const dateA = new Date(a.date).getTime()
    const dateB = new Date(b.date).getTime()
    return dateA - dateB
  })
  
  // Create deployment records
  deploymentCommits.forEach((commit, index) => {
    deploymentVersion.minor += 1
    const version = `${deploymentVersion.major}.${deploymentVersion.minor}.0`
    
    // Get commits in this deployment (commits since last deployment)
    const previousDeployment = deployments[deployments.length - 1]
    const previousCommit = previousDeployment ? previousDeployment.commit : null
    
    let deployedCommits = []
    if (previousCommit) {
      const commitIndex = commits.findIndex(c => c.hash === commit.hash)
      const previousIndex = commits.findIndex(c => c.hash === previousCommit)
      
      if (commitIndex > previousIndex) {
        deployedCommits = commits.slice(previousIndex + 1, commitIndex + 1)
          .filter(c => !c.message.toLowerCase().includes('bump version'))
      }
    } else {
      // First deployment - get all commits up to this one
      const commitIndex = commits.findIndex(c => c.hash === commit.hash)
      deployedCommits = commits.slice(0, commitIndex + 1)
        .filter(c => !c.message.toLowerCase().includes('bump version'))
    }
    
    deployments.push({
      version: version,
      date: commit.date,
      commit: commit.hash,
      shortCommit: commit.shortHash,
      commits: deployedCommits.map(c => ({
        hash: c.hash,
        shortHash: c.shortHash,
        message: c.message,
        author: c.author,
        date: c.date
      })),
      summary: `${deployedCommits.length} commit${deployedCommits.length !== 1 ? 's' : ''} deployed`,
      changes: {
        filesChanged: deployedCommits.length // Approximate
      }
    })
  })
  
  return deployments
}

function calculateCurrentVersion(commits, milestones, deployments) {
  // Find the latest milestone or deployment
  const allEvents = [
    ...milestones.map(m => ({ type: 'milestone', date: m.date, version: m.version })),
    ...deployments.map(d => ({ type: 'deployment', date: d.date, version: d.version }))
  ].sort((a, b) => {
    const dateA = new Date(a.date).getTime()
    const dateB = new Date(b.date).getTime()
    return dateB - dateA
  })
  
  const latestEvent = allEvents[0]
  const latestVersion = latestEvent ? latestEvent.version.split('.').map(Number) : [1, 0, 0]
  
  // Count commits since last major version
  const lastMajorDate = milestones.length > 0 ? milestones[0].date : commits[0]?.date
  const commitsSinceMajor = commits.filter(c => {
    const commitDate = new Date(c.date).getTime()
    const majorDate = new Date(lastMajorDate).getTime()
    return commitDate >= majorDate
  }).length
  
  // Count deployments since last major
  const deploymentsSinceMajor = deployments.filter(d => {
    const deployDate = new Date(d.date).getTime()
    const majorDate = new Date(lastMajorDate).getTime()
    return deployDate >= majorDate
  }).length
  
  return {
    major: latestVersion[0] || 1,
    minor: latestVersion[1] || deploymentsSinceMajor,
    patch: commitsSinceMajor,
    lastMajorUpdate: lastMajorDate || new Date().toISOString().split('T')[0],
    lastDeployment: deployments.length > 0 ? deployments[deployments.length - 1].date : null,
    lastDeploymentCommit: deployments.length > 0 ? deployments[deployments.length - 1].commit : null,
    commitsSinceLastMajor: commitsSinceMajor,
    deploymentsSinceLastMajor: deploymentsSinceMajor
  }
}

function main() {
  console.log('ğŸ” Initializing version history from git...\n')
  
  if (!checkGitAvailable() || !checkGitRepository()) {
    console.error('âŒ Git is not available or not in a git repository')
    process.exit(1)
  }
  
  // Ensure versions directory exists
  if (!fs.existsSync(versionsDirectory)) {
    fs.mkdirSync(versionsDirectory, { recursive: true })
  }
  
  // Get git commits
  console.log('ğŸ“ Analyzing git commit history...')
  const commits = getCommitsByCategory()
  console.log(`   Found ${commits.length} commits`)
  
  if (commits.length === 0) {
    console.error('âŒ No commits found in repository')
    process.exit(1)
  }
  
  // Identify milestones
  console.log('\nğŸ† Identifying milestones...')
  const milestones = identifyMilestones(commits)
  console.log(`   Found ${milestones.length} milestones`)
  
  // Identify deployments
  console.log('\nğŸš€ Identifying deployments...')
  const deployments = identifyDeployments(commits)
  console.log(`   Found ${deployments.length} deployments`)
  
  // Calculate current version
  console.log('\nğŸ“Š Calculating current version...')
  const currentVersion = calculateCurrentVersion(commits, milestones, deployments)
  console.log(`   Current version: ${currentVersion.major}.${currentVersion.minor}.${currentVersion.patch}`)
  
  // Save milestones
  console.log('\nğŸ’¾ Saving milestones...')
  fs.writeFileSync(milestonesFile, JSON.stringify({ milestones }, null, 2))
  console.log(`   âœ… Saved ${milestones.length} milestones to ${milestonesFile}`)
  
  // Save deployments
  console.log('\nğŸ’¾ Saving deployments...')
  fs.writeFileSync(deploymentsFile, JSON.stringify({ deployments }, null, 2))
  console.log(`   âœ… Saved ${deployments.length} deployments to ${deploymentsFile}`)
  
  // Save current version
  console.log('\nğŸ’¾ Saving current version...')
  fs.writeFileSync(versionFile, JSON.stringify(currentVersion, null, 2))
  console.log(`   âœ… Saved current version to ${versionFile}`)
  
  console.log('\nâœ… Version history initialization complete!')
  console.log(`\n   Summary:`)
  console.log(`   - Milestones: ${milestones.length}`)
  console.log(`   - Deployments: ${deployments.length}`)
  console.log(`   - Current Version: ${currentVersion.major}.${currentVersion.minor}.${currentVersion.patch}`)
  console.log(`   - Total Commits: ${commits.length}`)
  console.log(`\n   Files created:`)
  console.log(`   - ${milestonesFile}`)
  console.log(`   - ${deploymentsFile}`)
  console.log(`   - ${versionFile}`)
  console.log(`\n   âš ï¸  Review and adjust milestones as needed!`)
}

if (require.main === module) {
  main()
}
